В ответах на вопросы о проектировании комбинационных схем используйте операторы assign и/или always_comb.

2.6. Автомат, выдающий сдачу. (Интересно, что эта задача была опубликована в номере Wall Street Journal от 9 ноября 2011 года в статье о студентах, стремящихся выбрать профилирующий предмет полегче. Задача не такая уж и простая.)
	
Мы все привыкли к звону монет в торговом автомате. А как автомат определяет, сколько сдачи дать (и надо ли ее давать вообще)? В этом и состоит суть задачи - реализовать комбинационную часть схемы, отвечающей за выдачу сдачи.
	
Предположим, что где-то внутри автомата имеется ящик, заполненный монетами по 5, 10 и 25 центов. Предположим также, что нам известны цена товара и сумма, уплаченная покупателем. Требуется спроектировать комбинационную схему, которая делает две вещи:
	О определяет, достаточно ли в ящике денег, чтобы выдать сдачу;
	О определяет две монеты наивысшего достоинства, которые должны быть выданы в составе сдачи.

Если быть более точным, требуется по значениям указанных ниже входов генерировать значения указанных ниже выходов. У схемы 5 многобитных входов и 6 многобитных выходов, а именно:
	О Cost [3:0]: 4-битный вход (беззнаковое целое), представляющий стоимость покупаемого товара в 5-центовиках. Суммы, не кратные 5 центам, не допускаются! Максимальная стоимость равна 15*5 = 75 центам;
	О Paid [3:0]: 4-битный вход (беззнаковое целое), представляющий денежную сумму (число 5-центовиков), уплаченную покупателем (суммы, не кратные 5 центам, также не допускаются). Максимальная сумма равна 15*5 = 75 центам;
	О Quarters [10]: 2-битный вход (беззнаковое целое), представляющий число 25-центовиков (quarters), доступных для сдачи;
	О Dimes [1:0]: 2-битный вход (беззнаковое целое), представляющий число 10-центовиков (diшеs),доступныхдля сдачи;
	О Nickels [1:0]: 2-битный вход (беззнаковое целое), представляющий число 5-центовиков (nickels), доступных для сдачи;
	О FirstCoin[2:0]: 3-битный выход, показывающий достоинство (в 5-центовиках) первой возвращенной монеты. Он может принимать значения 3'b001, 3'b010 и 3'b101 (5 центов, 10 центов и 25 центов), а также 3'b000· (монеты нет). Значение выхода должно соответствовать монете старшего достоинства из имеющихся в ящике и подлежащих выдаче. Например, если покупателю нужно вернуть 15 центов, выход FirstCoin должен иметь значение 3'b010- 10 центов. Конечно, так будет, только если 10-центовики есть в наличии (см. вход Dimes выше). Если же их нет, значение FirstCoin должно соответствовать 5 центам (при наличии 5-центовиков);
	О SecondCoin[2:0]: 3-битный выход, показывающий достоинство (в 5-центовиках) второй возвращенной монеты. Он, как и выход FirstCoin, может принимать значения 3'b001, 3'b010, 3'b101 и 3'b000. Значение должно соответствовать монете старшего достоинства, подлежащей выдаче (с учетом первой монеты). Например, если покупателю нужно вернуть 20 центов, значение FirstCoin должно соответствовать 10 центам (при наличии 10-центовиков), значение SecondCoin - тоже (если их не менее двух). Если же таковых монет нет, оба значения должны соответствовать 5 центам (при наличии 5-центовиков) (понятно, что в этом случае покупатель не получит свою сдачу полностью(Предполагается, что сдача состоит из двух или менее монет.);
	О ExactAmount: 1-битный выход, показывающий, что уплаченная сумма в точности равна цене товара, поэтому сдача не нужна (т. е. Paid == Cost, и ни одно из чисел не равно 0);
	О NotEnoughChange: 1-битный выход, показывающий, что требуется выдать сдачу, но у нас нет монет нужного достоинства (отметим, что речь идет не о выдаче двух 5-центовиков вместо одного 10-центовика. Проблема в том, что мы остались должны покупателю - он может начать колотить по автомату!);
	О CoughUpMore: 1-битный выход, показывающий, что значение Paid меньше значения Cost;
	О Remaining[3:0]: 4-битный выход, показывающий, сколько 5-центовиков мы остались должны покупателю (Paid - Cost - FirstCoin - SecondCoin).
	
Внимательный читатель уже, наверное, сосчитал, что на вход подается 14 бит, а на выходе выдается 13. Это означает, что таблица истинности содержит 27 столбцов и 16 384 строки. Не бросайтесь писать заявление об отказе от курса! Нужно придумать, как разбить модель на меньшие части, которые были бы обозримы. Потом можно будет составить из них единое целое.

Существует несколько способов разбить большую задачу на подзадачи; по мере накопления опыта вы научитесь отличать хорошие от плохих. Модель аппаратуры разбивается на модули, создаются экземпляры модулей и соединяются между собой; выходы одних модулей подаются на входы других.

Такой подход часто называют функциональным разбиением - выделяются основные функциональные элементы системы, которые разбиваются на меньшие части, проектируемые независимо. Например, для того чтобы определить первую монету сдачи, нужно сначала узнать общую сумму сдачи. Соответствующий комбинационный модуль просто вычисляет разность Change=Paid-Cost. Вот так внезапно восемь входных битов были перемещены в часть модели.

Как подступиться? Сначала нарисуйте диаграмму из модулей, реализующих простые функции. Такая схема, состоящая из основных комбинационных блоков (always_comb и assign), будет служить планом проекта. 
Затем приступайте к кодированию модулей. Вычисление в каждом модуле должно быть описано оператором always_comb или assign (возможно, несколькими).
Проверьте свою модель в симуляторе (не выводите на консоль всю таблицу истинности!). Разработайте тестовое окружение. 

Примечание. В SystemVerilog обычно используются беззнаковые числа. Если вы напишете if (а>=b) ... , ветвь then будет исполнена, когда а>=b (в предположении, что а и b - беззнаковые числа). Например, 1111 больше 0101 (15 больше 5). Это относится ко всем операторам<, >, <=, >=, ==, !=.
Нужно понимать, что если вычислить с = а - b, а затем написать if (с>=0) ... , то условие всегда будет истинным. Напротив, в if (с<0) ... условие всегда будет ложным. Это правильно: с - беззнаковое число, оно всегда больше или равно 0! Не делайте так: используйте операторы вида -if (а>b) ... или if (а==b). Также отметим, что в if (с>0) ... ветвь then будет исполнена при любом значении с, кроме 0.